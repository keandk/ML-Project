{
  "version": "2.1.0",
  "$schema": "https://json.schemastore.org/sarif-2.1.0.json",
  "runs": [
    {
      "properties": {
        "id": 153236,
        "version": "1.0.0",
        "type": "source code",
        "status": "candidate",
        "submissionDate": "2015-10-06",
        "language": "c",
        "author": "IARPA STONESOUP Test and Evaluation team",
        "description": "This test case creates a buffer on the stack of 1024 bytes and a struct on the heap containing a 64-byte buffer and a pointer to the beginning of that buffer. It copies the taint source into the 1024-char buffer. It checks if the length of the taint source is less than the length of the 64-byte buffer. If it is, it uses strncpy to copy the taint source into the 64-byte buffer, with a maximum value of 1024 bytes. However, strncpy always writes the maximum number of bytes, and so writes 1024 bytes. This overflows the other data in the struct, including the pointer that originally pointed to the beginning of the 64-byte buffer. The test case then calls strlen on that pointer in the struct. However, since the pointer has been corrupted by the overflow, this causes a segmentation fault. \nMetadata\n - Base program: PostgreSQL\n - Source Taint: ENVIRONMENT_VARIABLE\n - Data Type: TYPEDEF\n - Data Flow: BUFFER_ADDRESS_ARRAY_INDEX\n - Control Flow: CALLBACK",
        "state": "bad",
        "application": "cpe:2.3:a:postgresql:postgresql:9.2.4:*:*:*:*:*:*:*",
        "dependencies": [
          "stonesoup-vm-v3.0",
          "postgresql-v9.2.4"
        ]
      },
      "tool": {
        "driver": {
          "name": "SARD - SAMATE",
          "fullName": "Software Assurance Reference Dataset Project",
          "informationUri": "https://samate.nist.gov/SARD/",
          "version": "5.0.0",
          "organization": "NIST",
          "supportedTaxonomies": [
            {
              "name": "CWE",
              "index": 0
            }
          ]
        }
      },
      "artifacts": [
        {
          "location": {
            "uri": "C-C806C-PSQL-02-ST01-DT06-DF16-CF01-01.xml"
          },
          "length": 73610,
          "sourceLanguage": "xml",
          "hashes": {
            "sha-256": "21ceb498859b8d435ad046d33d687ebf3960d7d025577ebc47bfc73381bf0d59"
          }
        },
        {
          "location": {
            "uri": "src/src/backend/utils/hash/dynahash.c"
          },
          "length": 54296,
          "sourceLanguage": "c",
          "hashes": {
            "sha-256": "2b5c0ee425cdd95a69744a49e2e141ce7abdb0375d414028c2afe2cd124133c5"
          }
        }
      ],
      "taxonomies": [
        {
          "name": "CWE",
          "version": "4.6",
          "informationUri": "https://cwe.mitre.org/data/published/cwe_v4.6.pdf",
          "downloadUri": "https://cwe.mitre.org/data/xml/cwec_v4.6.xml.zip",
          "organization": "MITRE",
          "shortDescription": {
            "text": "The MITRE Common Weakness Enumeration"
          },
          "isComprehensive": false,
          "taxa": [
            {
              "id": "806",
              "name": "Buffer Access Using Size of Source Buffer"
            }
          ]
        }
      ],
      "results": [
        {
          "ruleId": "CWE-806",
          "message": {
            "text": "Buffer Access Using Size of Source Buffer."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/src/backend/utils/hash/dynahash.c",
                  "index": 1
                },
                "region": {
                  "startLine": 1551,
                  "endLine": 1555
                }
              }
            }
          ],
          "taxa": [
            {
              "toolComponent": {
                "name": "CWE",
                "index": 0
              },
              "id": "806",
              "index": 0
            }
          ]
        }
      ]
    }
  ]
}
